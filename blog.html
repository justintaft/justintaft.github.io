<!DOCTYPE html>
<html>
<head>
<title>Justin Taft</title>
<meta name="viewport" content= "width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body class="blog">
<div>
<h1>Justin Taft</h1>
<p>
<a href="index.html">Home</a> / <a href="https://github.com/justintaft">Github</a> / <a href="https://www.linkedin.com/in/justin-taft/">LinkedIn</a> / <a href="https://www.oneupsecurity.com">Consulting Services</a></p>
</div>

<h3>On Emacs</h3>

<p>January 10th, 2020</p>

<p>Over the last 20 years I've used many  environments for programming and editing files (vim, Emacs, Eclipse, NetBeans, PHPStorm, Visual Studio, just to name some). While I will use the right tool for the right job, I'm partial to Emacs.</p>

<p><strong>Emacs is easy to extend</strong> - You can modify Emacs while it's running, within Emacs. There is no need for a separate development environment. You write some elisp and then evaluate the expressions within Emacs. There is no need to set up a project for plugin development, and no need to learn a custom language with lots of syntax. I'm not a fan of vimscript, powershell, or scala for this reason, but i digress.</p>

<p><strong>Emacs allows you to optimize your workflow</strong> - I dislike having to switch between multiple applications, it's a waste of time. As Emacs is easy to extend, you can optimize your workflow so everything is a few keystrokes away. For projects, I manage my todo-list, program, run shell commands, and do technical writing all within Emacs. I even have grammar checking in Emacs thanks to integrating language tool.</p>

<p><strong>Emacs allows you to program using keyboard macros</strong> - Keyboard macros allows you save keystrokes/executed commands and run them later. This allows you to be really hacky and get things done quickly. Need a one-off program to save the current file, then execute a shell command? Write a macro. Need a one-off program to move the current line to a different buffer? Use a macro. Any one-off action you find repetitive and it's not worth writing elisp for, try writing a macro instead. The real ah-ha moment for me is when I realized you can run any function that's not bound to an active key, such as with <em>M-x function-name</em>. </p>

<p>Keep in mind other people don't use Emacs, so for project-related repetitive operations, they should be within a build script of some sort.</p>

<p>Of course, there are downsides to using Emacs.</p>

<p><strong>Learning Emacs takes time</strong> - The way I think about Emacs is it's a programming environment for itself. Key bindings are merely shortcuts to invoking  elisp functions. When you write elisp, you will have to spend time learning it's core API. Emacs introspection helps though.</p>

<p><strong>Configuring Emacs takes time</strong> - You have to invest time to tweak Emacs the way you want it, and it's never perfect. You have to remind yourself to invest your time wisely to achieve your goals. Sometimes it's better not to modify Emacs so you can your real work done.</p>

<p><strong>Emacs is insecure</strong> - Emacs does not verify TLS certificates by default, which is insane. Additionally it's common to download packages from melpa/github to configure Emacs how you want it. As these packages are executed within Emacs, this can easily lead to malware being installed on your computer. Even worse, you essentially can't trust that what you see on the screen is actually is not is tampered with. For this reason, I review elisp which I use in my setups. Additionally, I sandbox Emacs in such a way where it would be hard for malware to exfiltrate data. </p>

<p>It would be great if there was a straight forward method to  access multiple compartmentalized Emacs instances from a trusted Emacs instance. This would be useful to restrict what compromised Emacs instances can access.</p>
<h3>.NET Deserilization Gadgets</h3>

<p>December 25, 2019</p>

<p>The use of <code>BinaryFormatter</code> in .NET applications often leads to Remote Code Execution quite easily. See https://github.com/pwntester/ysoserial.net for example gadgets.</p>

<p>When testing the TypeConfuseDelegate payload in your own project, a couple of exceptions may be thrown:</p>

<ul>
<li><p>'Object must implement IConvertible' - This occurs when the appropriate deserialization types can not be found. Check to ensure you are compiling with a .NET Framework project to instead of .NET Core.</p></li>
<li><p>"System.IO.FileNotFoundException: 'Could not load file or assembly 'System' or one of its dependencies. The system cannot find the file specified.'" - An easy way to fix the runtime error for your Proof of Concept is by adding a <code>System</code> reference to the project, and setting <code>Copy Local</code> to <code>True</code>. This causes the <code>System.dll</code> file to copied to the build directory.</p></li>
</ul>

<p>Often developers try to re-mediate Deserialization bugs by whitelisting which types can be deserialized. In .NET applications, the <code>System</code> assembly gets whitelisted often. However, known remote code execution gadgets exist in <code>System</code>, and can be leveraged to gain remote code execution. </p>

<p>A recommended fix is to use a Deserialization framework that doesn't allow arbitrary types to be deserialized, such as JSON. </p>
<h3>Applying SELinux Tags To Allow Cross-VM Disk Access</h3>

<p>December 11, 2019</p>

<p>Fedora uses SELinux's Multi Category Security to restrict VMs from accessing other VMs backing disks. Each VM is assigned a randomized category number when starting. When accessing a VM disk file from another running VM, such as by sharing a directory, an error similar to the following is logged by systemd:</p>

<p><code>
audit[26742]: AVC avc:  denied  { read } for  pid=26742 comm="worker" name="testvm.qcow2" dev="dm-6" ino=24642243 scontext=unconfined_u:unconfined_r:svirt_t:s0:c501,c650 tcontext=unconfined_u:object_r:user_home_t:s0 tclass=file permissive=0
</code></p>

<p>SELinux tags can be applied to the running qemu process for the VM to allow read and write access to all VM disks.  To allow a VM named <code>backup</code> to have read and write access to other VM backing files, run <code>virsh editxml --domain backup</code> and insert the following before <code>&lt;/domain&gt;</code>:</p>

<p><code>
&lt;seclabel type='static' model='selinux' relabel='yes'&gt;
  &lt;label&gt;unconfined_u:unconfined_r:svirt_t:s0:c0.c1023&lt;/label&gt;
&lt;/seclabel&gt;
</code></p>

<p>Ideally, a custom SELinux policy should be created to allow read-only access to backing disks. However, mounting backing disk files as readonly within a VM through libvirt and leveraging user, groups, and file permissions to further enforce read-only access may be acceptable.</p>
<h3>Creating and backing up security sensitive VMs using KVM and Borg</h3>

<p>Nov 17, 2019</p>

<p>It's Thursday night. You've been hacking away at a web app all week. All of a sudden your laptop turns off because you forgot to plug in the power cord. No bigge you think. You plug your laptop in, boot it up, and start the VM you've been using. <em>Crap</em>, you sigh to yourself, as you realize your proxy project file is corrupted. You start hunting for the bugs you've already discovered, muttering to yourself you should have had a backup plan in place.</p>

<p>Sound familiar? Hopefully not! But if so, let's see how we can mitigate this from occurring.</p>

<p>At its core, we need a way to backup VMs which have an encrypted data store. VM Backups should occur behind the scenes, and downtime should be minimum (under a second at most). Additionally, we are aiming for crash consistency.  There are a few ways to achieve this, but this is one of the less complex methods in my opinion: </p>

<ul>
<li><p>VMs should use two separate disk files. The first file is for storing root, boot, home,var, etc. The second file is just for swap. We don't back up the swap disk file  as it's highly volatile and not necessary. Our backups would grow quite large if we backed up swap every night.</p></li>
<li><p>We use virsh's snapshot-create-as feature to create copy-on-write snapshots, and merge them back in with virsh blockcommit.</p></li>
<li><p>We use LUKS inside the VM for encryption. From the hypervisor perspective, this simplifies VM provisioning and the backup process for a few reasons.  For instance, the hypervisor doesn't need to know how to decrypt the VM's backend store to start the VM, or how to securely store temporary snapshots. VMs leveraging encryption which need to be started in an automated fashion can use network bound disk encryption methods. Additionally, each VM should have it's own master encryption key, to mitigate risk of a key being compromised (ie, if a VM is exploited and root is obtained within the VM.). </p></li>
<li><p>We use sparse qcow2 files to allow disk files to grow when needed. This can lead to over-committing disk space, but it's a trade-off that allows you to re-use a template vm for easier provisioning. The backup process can also perform de-duplication for unused blocks, as they will appear as a bunch of zeros in sparse images.</p></li>
<li><p>To keep the hypervisor vanilla as possible, a  separate VM for backing up files  is used. The files to be backed up can be mounted as readonly within the backup VM.  Note as the VM files are encrypted, the risk of the backup VM accidentally backing up sensitive data is mitigated. For additional security,  VM images can be signed, to verify they have not been tampered with.</p></li>
<li><p>If necessary, a script is run within the VM before the snapshot is taken to close applications which don't support crash-consistency. After the snapshot is made, the application is re-started. The script can be triggered through SSH for instance.</p></li>
<li><p>AMD's Secure Memory Encryption and Secure Encrypted Virtualisations can be used to protect against physical attacks, and mitigate the risk of a malicious attack carried out in the hypervisor to read the VM's memory. Ie, the hypervisor would only see encrypted data if attempting to read the guest VM's memory directly. I imagine a backdoor can be placed on a system however to defeat the mitigation.</p></li>
</ul>

</body>
</html>


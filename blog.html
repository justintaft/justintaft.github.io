<!DOCTYPE html>
<html>
<head>
<title>Justin Taft</title>
<meta name="viewport" content= "width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body class="blog">
<div>
<h1>Justin Taft</h1>
<p>
<a href="index.html">Home</a> / <a href="https://github.com/justintaft">Github</a> / <a href="https://www.linkedin.com/in/justin-taft/">LinkedIn</a> / <a href="https://www.oneupsecurity.com">Consulting Services</a></p>
</div>

<h3>Applying SELinux Tags To Allow Cross-VM Disk Access</h3>

<p>December 11, 2019</p>

<p>Fedora uses SELinux's Multi Category Security to restrict VMs from accessing other VMs backing disks. Each VM is assigned a randomized category number when starting. When accessing a VM disk file from another running VM, such as by sharing a directory, an error similar to the following is logged by systemd:</p>

<p><code>
audit[26742]: AVC avc:  denied  { read } for  pid=26742 comm="worker" name="testvm.qcow2" dev="dm-6" ino=24642243 scontext=unconfined_u:unconfined_r:svirt_t:s0:c501,c650 tcontext=unconfined_u:object_r:user_home_t:s0 tclass=file permissive=0
</code></p>

<p>To allow a VM access to other VMs backing disks, you can apply a SELinux tag to the running qemu process allow access to all disks. To allow a VM named <code>backup</code> to have read and write access to other VM backing files, run <code>virsh editxml --domain backup</code> and insert the following before <code>&lt;/domain&gt;</code>:</p>

<p><code>
&lt;seclabel type='static' model='selinux' relabel='yes'&gt;
  &lt;label&gt;unconfined_u:unconfined_r:svirt_t:s0:c0.c1023&lt;/label&gt;
&lt;/seclabel&gt;
</code></p>

<p>Ideally, a custom SELinux policy should be created to allow read-only access to backing disks. However, mounting backing disk files as readonly within a VM through libvirt may be an acceptable  compromise on complexity and in-depth security for your scenario.</p>
<h3>Encrypted VMs and Backups with KVM and Borg</h3>

<p>Nov 17, 2019</p>

<p>It's Thursday night. You've been hacking away at a web app all week. All of a sudden your laptop turns off because you forgot to plug in the power cord. No bigge you think. You plug your laptop in, boot it up, and start the VM you've been using. <em>Crap</em>, you sigh to yourself, as you realize your proxy project file is corrupted. You start hunting for the bugs you've already discovered, muttering to yourself you should have had a backup plan in place.</p>

<p>Sound familiar? Hopefully not! But if so, let's see how we can mitigate this from occurring.</p>

<p>At its core, we need a way to backup VMs which have an encrypted data store. VM Backups should occur behind the scenes, and downtime should be minimum (under a second at most). Additionally, we are aiming for crash consistency.  There are a few ways to achieve this, but this is one of the less complex methods in my opinion: </p>

<ul>
<li><p>VMs should use two separate disk files. The first file is for storing root, boot, home,var, etc. The second file is just for swap. We don't back up the swap disk file  as it's highly volatile and not necessary. Our backups would grow quite large if we backed up swap every night.</p></li>
<li><p>We use virsh's snapshot-create-as feature to create copy-on-write snapshots, and merge them back in with virsh blockcommit.</p></li>
<li><p>We use LUKS inside the VM for encryption. From the hypervisor perspective, this simplifies VM provisioning and the backup process for a few reasons.  For instance, the hypervisor doesn't need to know how to decrypt the VM's backend store to start the VM, or how to securely store temporary snapshots. VMs leveraging encryption which need to be started in an automated fashion can use network bound disk encryption methods. Additionally, each VM should have it's own master encryption key, to mitigate risk of a key being compromised (ie, if a VM is exploited and root is obtained within the VM.). </p></li>
<li><p>We use sparse qcow2 files to allow disk files to grow when needed. This can lead to over-committing disk space, but it's a trade-off that allows you to re-use a template vm for easier provisioning. The backup process can also perform de-duplication for unused blocks, as they will appear as a bunch of zeros in sparse images.</p></li>
<li><p>To keep the hypervisor vanilla as possible, a  separate VM for backing up files  is used. The files to be backed up can be mounted as readonly within the backup VM.  Note as the VM files are encrypted, the risk of the backup VM accidentally backing up sensitive data is mitigated. For security however, the files will be wrapped with encryption. For additional security, the VM files can be signed before being exposed to the backup VM, in case the backup VM becomes compromised.</p></li>
<li><p>If necessary, a script is run within the VM before the snapshot is taken to close applications which don't support crash-consistency. After the snapshot is made, the application is re-started. The script can be triggered through SSH for instance.</p></li>
<li><p>AMD's Secure Memory Encryption and Secure Encrypted Virtualisations can be used to protect against physical attacks, and mitigate the risk of a malicious attack carried out in the hypervisor to read the VM's memory. Ie, the hypervisor would only see encrypted data if attempting to read the guest VM's memory directly. I imagine a backdoor can be placed on a system however to defeat the mitigation.</p></li>
</ul>

</body>
</html>

